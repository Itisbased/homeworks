package hw

/**
  * Все задачи необходимо реализовать через хвостовую рекурсию.
  */

/**
  * 1. Реализуйте метод, который переворачивает неотрицательные числа
  *
  *  swap(327849) = 948723
  *  swap(1) = 1
  *  swap(100) = 1
  *  swap(42) = swap(24)
  */
def swap(x: Long): Long =
  @annotation.tailrec
  def loop(n: Long, acc: Long): Long =
    if (n == 0) acc
    else loop(n / 10, acc * 10 + (n % 10))

  loop(x, 0)

/**
  * 2. Реализуйте метод, возвращающий n-ое число последовательности:
  *
  *  1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, ....
  *  (каждое число повторяется ровно столько раз, чем равно это самое число)
  *
  *  selfRepeat(0) = 1
  *  selfRepeat(1) = 2
  *  selfRepeat(2) = 2
  *  selfRepeat(2) = 3
  *  selfRepeat(10) = 5
  *  selfRepeat(42) = 9
  */
def selfRepeat(n: Int): Int =
  @annotation.tailrec
  def loop(i: Int, count: Int): Int =
    if (n <= count + i - 1) i
    else loop(i + 1, count + i)

  loop(1, 0)

/**
  * 3. Фибоначчи, делящиеся на k
  *
  * Рассмотрим последовательность Фибоначчи:
  *
  *  0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711 ...
  *
  * Давайте рассмотрим последовательность, которая берет только числа, делящиеся на (k > 1):
  *    (k = 2): 0, 2, 8, 34, 144, 610, 2584, 10946, 46368, 196418, 832040, 3524578, 14930352, 63245986, 267914296, 1134903170, 4807526976 ...
  *    (k = 3): 0, 3, 21, 144, 987, 6765, 46368, 317811, 2178309, 14930352, 102334155, 701408733, 4807526976, 32951280099, 225851433717, ...
  *    (k = 4): 0, 8, 144, 2584, 46368, 832040, 14930352, 267914296, 4807526976, 86267571272, 1548008755920, ...
  *    ...
  *
  * Необходимо реализовать метод, который берет на вход (k > 1, n >= 0) и возвращает n-ый эелемент последовательности для делителя k.
  *
  *    fibDiv(2, 0) = 0
  *    fibDiv(2, 1) = 2
  *    fibDiv(2, 2) = 8
  *
  *    fibDiv(3, 0) = 0
  *    fibDiv(3, 1) = 2
  *    fibDiv(3, 2) = 21
  *
  *    fibDiv(10, 2) = 832040
  */
def fibDiv(k: Int, n: Int): Long =
  @annotation.tailrec
  def loop(f1: Long, f2: Long, count: Int): Long =
    if (count >= n) f1
    else if (f2 % k == 0) loop(f2, f1 + f2, count + 1)
    else loop(f2, f1 + f2, count)

  loop(0, 1, 0)

/**
  * 4. (* опционально) Максимум в дереве
  *
  * Задана структура данных --- (полное) бинарное дерево, в узлах и листьях которого значения типа Int
  */
enum Tree:
  def value: Int

  case Node(value: Int, left: Tree, right: Tree)
  case Leaf(value: Int)

import Tree.*

/**
  * 4.1 Реализовать метод maxT, который находит максимум в дереве:
  *
  * Для такого дерева:
  *
  *            10
  *          /     \
  *         1       -3
  *      /     \
  *     13      42
  *           /   \
  *         32     14
  *        /   \
  *       41    0
  *
  * Результат метода должен быть 42.
  *
  *
  *
  */
def maxT(tree: Tree): Int =
  @annotation.tailrec
  def loop(stack: List[Tree], currMax: Int): Int = stack match
    case Nil                             => currMax
    case Leaf(curr) :: tail              => loop(tail, currMax max curr)
    case Node(curr, left, right) :: tail => loop(left :: right :: tail, currMax max curr)

  loop(List(tree), tree.value)

/**
  * 4.2
  *
  * Реализовать метод mapT, который применяет функцию f: Int => Int ко
  * всем значениям в дереве
  *
  * Для такого дерева и функции (_ * 2):
  *
  *            10
  *          /     \
  *         1       -3
  *      /     \
  *     13      42
  *           /   \
  *         32     14
  *        /   \
  *       41    0
  *
  * Результат должен быть:
  *
  *
  *             20
  *          /     \
  *         2       -6
  *      /     \
  *     26      84
  *           /   \
  *         64     28
  *        /   \
  *       82    0
  *
  */
def mapT(t: Tree, f: Int => Int): Tree = ???
